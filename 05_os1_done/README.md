# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

1. Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной  программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. Вам нужно найти тот единственный, который относится именно к `cd`. <br/><br/>
***Ответ:*** <br/>
Системный вызов команды CD: chdir("/tmp") <br/>
В выводе данный вызов выглядит так: chdir("/tmp") = 0 <br/> <br/>

2. Попробуйте использовать команду `file` на объекты разных типов на файловой системе. Например:
    ```bash
    vagrant@netology1:~$ file /dev/tty
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
    vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64
    ```
    Используя `strace` выясните, где находится база данных `file` на основании которой она делает свои догадки. <br/><br/>
***Ответ:*** <br/>
Файл базы данных команды file находится: /usr/share/misc/magic.mgc <br/>
В выводе это: openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3 <br/><br/>
3. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе). <br/><br/>
***Ответ:*** <br/>
Для решения задачи использовал скрипт написанный на Python, который бесконечно выводит строку в файл /opt/1.log, после запуска скрипта файл был удалён <br/>
Далее командой: `lsof -p 1126` вывел информацию о процессе <br/>

> `root@jbg1-app04:~# lsof -p 1815` <br/>
> `...` <br/>
> `python3 1815 root    3w   REG  253,0 1740407760 5242882 /opt/1.log (deleted)` <br/>
> `root@jbg1-app04:~# echo '' > /proc/1815/fd/3`

Где 1815 - PID процесса python, а 3 дескриптор файла <br/><br/>

4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)? <br/><br/>
***Ответ:*** <br/>
"Зомби" процессы освобождают свои ресурсы, но не освобождают запись в таблице процессов. <br/>
Запись освободиться при вызове wait() родительским процессом. 


5. В iovisor BCC есть утилита `opensnoop`:
    ```bash
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc
    ```
    На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04. Дополнительные [сведения по установке](https://github.com/iovisor/bcc/blob/master/INSTALL.md). <br/><br/>
***Ответ:***
> root@jbg1-app04:/opt# dpkg -L bpfcc-tools | grep sbin/opensnoop <br/>
> /usr/sbin/opensnoop-bpfcc <br/>
> root@jbg1-app04:/opt# /usr/sbin/opensnoop-bpfcc<br/>
> PID    COMM               FD ERR PATH<br/>
> 746    irqbalance          6   0 /proc/interrupts<br/>
> 746    irqbalance          6   0 /proc/stat<br/>
> 746    irqbalance          6   0 /proc/irq/1/smp_affinity<br/>
> 746    irqbalance          6   0 /proc/irq/6/smp_affinity<br/>
> 746    irqbalance          6   0 /proc/irq/8/smp_affinity<br/>
> 746    irqbalance          6   0 /proc/irq/12/smp_affinity<br/>
> 746    irqbalance          6   0 /proc/irq/14/smp_affinity<br/>
> 746    irqbalance          6   0 /proc/irq/15/smp_affinity<br/>

6. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС. <br/><br/>
***Ответ:*** <br/>
Системный вызов uname() <br/>
Цитата: 
> Part of the utsname information is also accessible  via  /proc/sys/ker‐
       nel/{ostype, hostname, osrelease, version, domainname}.

7. Чем отличается последовательность команд через `;` и через `&&` в bash? Например:
    ```bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#
    ```
    Есть ли смысл использовать в bash `&&`, если применить `set -e`? <br/><br/>
***Ответ:*** <br/>
> ; - это разделитель последовательных команд <br/>
> && - это условный оператор

В первом примере где используется ; выводится Hi, потому что echo не зависить от результата работы
предшествующей команды, а во втором примере ничего не выводится так как результат предшествующей команды
равен 0, соответственно булево значение будет равно 0.
8. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях? <br/><br/>
***Ответ:***
> -x вывод трейса простых команд
> -o pipefail возвращает код возврата набора/последовательности команд, ненулевой при последней команды или 0 для успешного выполнения команд. <br/>
> -e прерывает выполнение исполнения при ошибке любой команды кроме последней в последовательности <br/>
> -u неустановленные/не заданные параметры и переменные считаются как ошибки, с выводом в stderr текста ошибки и выполнит завершение неинтерактивного вызова <br/>

Повышает деталезацию вывода ошибок(логирования), и завершит сценарий при наличии ошибок, на любом этапе выполнения сценария, кроме последней завершающей команды
9. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными). <br/><br/>
***Ответ:***
Самые частые
> S*(S,S+,Ss,Ssl,Ss+) - Процессы ожидающие завершения (спящие с прерыванием "сна") <br/>
> I*(I,I<) - фоновые(бездействующие) процессы ядра

доп символы это доп характеристики, например приоритет.


